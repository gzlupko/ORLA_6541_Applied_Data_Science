---
title: "ORLA 6541 Exercise 2"
author: "Nilima Ajaikumar, Hagay Jalon, Gian Zlupko"
date: 2022-10-11
output: html_document

---


# Healy Chapter 4
### "Show The Right Numbers"


Libaries used in Ch. 4 exercises 
```{r, message = FALSE}
library(gapminder)
library(tidyverse)
library(socviz)
library(ggrepel)
```


Explore gapminder data set 

```{r}
head(gapminder) 

gapminder %>% 
  arrange(desc(gdpPercap)) 
```


### 4.8 Where to Go Next

#### Revisit the gapminder plots at the beginning of the chapter and experiment with different ways to facet the data. Try plotting population and per capita GDP while faceting on year, or even on country. In the latter case you will get a lot of panels, and plotting them straight to the screen may take a long time. Instead, assign the plot to an object and save it as a PDF file to your figures/ folder. Experiment with the height and width of the figure.


```{r}

p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = pop))
p + geom_line(aes(group = country)) + facet_wrap(~year)
p + facet_wrap(~year)

```


```{r}
Healy_Ch.4_4.8.1 <- p + geom_line(aes(group = country)) + facet_wrap(~country)
```

```{r}
ggsave("Healy_4.8.1.pdf", plot=Healy_Ch.4_4.8.1, height=8, width=12)
```


```{r}
ggsave("Healy_4.8.1.pdf", plot=Healy_Ch.4_4.8.1, height=20, width=40)
```


```{r}
# in addition, we also generated a separate plot below by filtering down to select European countries while analyzing the same variables for a more manageable viz 

euro_gpd_pop <- gapminder %>% 
  filter(continent == "Europe", country %in% c("France", "Italy", "Germany", "Turkey")) %>%
  ggplot(aes(x = gdpPercap, y = pop)) + geom_line() + facet_wrap(~country, ncol = 4)

euro_gpd_pop + geom_smooth(size = 1.1, method = "loess", se = FALSE) + labs(x = "GDP per Captia",
         y = "Population",
         title = "GDP per capita on Five Continents")
```




### Investigate the difference between a formula written as facet_ grid(sex ~ race) and one written as facet_grid(~ sex + race).

```{r}
Age_Childs <-ggplot(gss_sm,mapping = aes(x = age, y = childs))
```


```{r, warning = FALSE, message = FALSE}
Age_Childs + 
  geom_point()+
  geom_smooth() +
  facet_grid(sex ~ race)
```


```{r, warning = FALSE, message = FALSE}
Age_Childs +  
  geom_point()+ 
  geom_smooth() + 
  facet_grid(~sex + race)
```

facet_ grid(sex ~ race) creates facets breaking out the data by sex (in the rows) and race (in the columns). facet_grid(~ sex + race) creats facets breaking out the data by sex and race using columns only, combining each uniqu race+sex value into a column. 

### Experiment to see what happens when you use facet_wrap() With more complex formulas like facet_wrap(~ sex + race) instead of facet_grid. Like facet_grid(), the facet_ wrap() function can facet on two or more variables at once.  But it will do it by laying the results out in a wrapped one dimensional table instead of a fully cross-classified grid.

```{r, warning = FALSE, message = FALSE}
Age_Childs +  
  geom_point() +
  geom_smooth() + 
  facet_wrap(~sex + race)
```


### Frequency polygons are closely related to histograms. Instead of displaying the count of observations using bars, they display it with a series of connected lines. You can try the various geom_histogram() calls in this chapter using geom_freqpoly() instead.

```{r, warning = FALSE, message = FALSE}
p <-  ggplot(data = midwest, mapping = aes(x = area))
p + geom_freqpoly() + ggtitle("Area of Counties in Midwest") + ylab("Count") + xlab("Area (units unknown)") 

```




```{r}
# also using frequency polygons to compare differences in distribution of county areas between IL and IN

midwest %>% 
  filter(state %in% c("IL", "IN")) %>% 
  ggplot(aes(x = area, fill = state, color = state)) + 
  geom_freqpoly(bins = 10) + labs(title = "Distribution of County Areas",
                                  subtitle = "Illinois and Indiana", 
                                  x = "Area", y = "Count", color = "State")    

```


```{r}
oh_wi <-  c("OH", "WI")
p <-  ggplot(data = subset(midwest, subset = state %in% oh_wi),
mapping = aes(x = percollege, fill = state, color = state))
p + geom_freqpoly(alpha = 0.5, bins = 20) + labs(color = "State", 
                                                 y = "Count", 
                                                 x = "Area") 
```


### A histogram bins observations for one variable and shows a bar with the count in each bin.  We can do this for two variables at once, too. The geom_bin2d() function takes two mappings, x and y. It divides your plot into a grid and colors the bins by the count of observations in them. Try using it on the gapminder data to plot life expectancy versus per capita GDP. Like a histogram, you can vary the number or width of the bins for both x or y. Instead of saying bins = 30 or binwidth = 1, provide a number for both x and y with, for example, bins = c(20, 50). If you specify binwidth instead, you will need to pick values that are on the same scale as the variable you are mapping.

```{r}

# store object 
life_expectancy_versus_per_capita_GDP <-  ggplot(data = gapminder, mapping = aes(x = lifeExp, y = gdpPercap))

# plot 
life_expectancy_versus_per_capita_GDP + geom_bin2d(bins=c(40,60)) 
```



### Density estimates can also be drawn in two dimensions. The geom_density_2d() function draws contour lines estimating the joint distribution of two variables. Try it with the midwest data, for example, plotting percent below the poverty line (percbelowpoverty) against percent college-educated (percollege). Try it with and without a geom_point() layer.

```{r}
percbelowpoverty_percollege <-  ggplot(data = midwest, mapping = aes(x = percbelowpoverty, y=percollege))
percbelowpoverty_percollege + geom_density_2d() + geom_point() + 
  labs(x = "% Below Poverty Line", y = "% Attended College", caption = 
         "Note: Demographic information of midwest counties\n from 2000 US census")  

```


# Healy Chapter 5 
### "Graphs, tables, labels and notes" 

Libraries used for Chapter 5 exercises 
```{r}
library(gapminder)
library(tidyverse)
library(socviz)
```


The following code chunks were developed as practice before answering the 'Where to Next' questions in the chapter. 

```{r}
rel_by_region <-  gss_sm %>%
group_by(bigregion, religion) %>%
summarize(N = n()) %>%
mutate(freq = N / sum(N),
pct = round((freq*100), 0))
```


```{r}
rel_by_region %>% group_by(bigregion) %>% summarize(total = sum(pct))
```

```{r}
p <-  ggplot(rel_by_region, aes(x = bigregion, y = pct, fill = religion))
p + geom_col(position='dodge2') +
labs(x = "Region",y = "Percent", fill = "Religion") +
theme(legend.position = "top")
```

```{r, message = FALSE, warning = FALSE}
p + geom_col(position = "dodge2") +
labs(x = NULL, y = "Percent", fill = "Religion") +
guides(fill = FALSE) +
coord_flip() +
facet_grid(~ bigregion)
```


```{r, warning = FALSE}
organdata %>% select(1:6) %>% sample_n(size = 10)
ggplot(organdata)+
  aes(x=year, y=donors)+
  geom_line(aes(group=country))+
  facet_wrap(~country)
```


```{r, warning=FALSE}
p <-  ggplot(data = organdata,
mapping = aes(x = reorder(country, donors, na.rm=TRUE),
y = donors, fill = world))
p + geom_boxplot() + labs(x=NULL) +
coord_flip() + theme(legend.position = "top")
```



```{r}
by_country <-  organdata %>% group_by(consent_law, country) %>%
summarize_if(is.numeric, funs(mean, sd), na.rm = TRUE) %>%
ungroup()
```


```{r}
p <- ggplot(data = by_country,
mapping = aes(x = donors_mean,
y = reorder(country, donors_mean)))
```



```{r}
p + geom_point(size=3) +
facet_wrap(~ consent_law,scales = "free_y", ncol = 1) +
labs(x= "Donor Procurement Rate",
y= "")
```


```{r}
library(ggrepel)
p <-  ggplot(data = by_country, mapping = aes(x = roads_mean,
y = donors_mean))
p + geom_text_repel(mapping = aes(label = country))
```


```{r}
elections_historic %>% select(2:7)
p_title <-  "Presidential Elections: Popular & Electoral College Margins"
p_subtitle <-  "1824-2016"
p_caption <-  "Data for 2016 are provisional."
x_label <-  "Winner's share of Popular Vote"
y_label <-  "Winner's share of Electoral College Votes"
p <-  ggplot(elections_historic, aes(x = popular_pct, y = ec_pct,
label = winner_label))
p + geom_hline(yintercept = 0.5, size = 1.4, color = "gray80") +
geom_vline(xintercept = 0.5, size = 1.4, color = "gray80") +
geom_point() +
geom_text_repel() +
scale_x_continuous(labels = scales::percent) +
scale_y_continuous(labels = scales::percent) +
labs(x = x_label, y = y_label, title = p_title, subtitle = p_subtitle,
caption = p_caption)
```

## 5.7 Where to Go Next

### We covered several new functions and data aggregation techniques in this chapter. You should practice working with them.

### The subset() function is very useful when used in conjunction with a series of layered geoms. Go back to your code for the presidential elections plot (fig. 5.18) and redo it so that it shows all the data points but only labels elections since 1992. You might need to look again at the elections_historic data to see what variables are available to you. You can also experiment with subsetting by political party, or changing the colors of the points to reflect the winning party.


```{r}
by_year <- ggplot(subset(elections_historic, reorder= year>1991))
```



```{r, warning = FALSE, message = FALSE}

# subset the elections data; year greater than 1988 as next election was 1992 
after_1992 <- elections_historic %>% group_by(year) %>% subset(year>1988) 

# pre-setting labels as objects so we can use later 
p_title <-  "Presidential Elections: Popular & Electoral College Margins"
p_subtitle <-  "1824-2016"
p_caption <-  "Data for 2016 are provisional."
x_label <-  "Winner's share of Popular Vote"
y_label <-  "Winner's share of Electoral College Votes"

p <-  ggplot(data=elections_historic, aes(x = popular_pct, y = ec_pct,
label = winner_label, color=win_party, shape=win_party))

p + geom_hline(yintercept = 0.5, size = 1.4, color = "gray80") +
  geom_vline(xintercept = 0.5, size = 1.4, color = "gray80") +
  geom_point() + geom_smooth()+
  geom_text_repel(data=subset(after_1992)) +
  scale_x_continuous(labels = scales::percent) +
  scale_y_continuous(labels = scales::percent) + labs(x = x_label, y = y_label, title = p_title, subtitle = p_subtitle,caption = p_caption)
```



```{r}
after_1992 <- elections_historic %>% group_by(year) %>% subset(year>1988)
```



```{r}
p_title <-  "Presidential Elections: Popular & Electoral College Margins"
p_subtitle <-  "1824-2016"
p_caption <-  "Data for 2016 are provisional."
x_label <-  "Winner's share of Popular Vote"
y_label <-  "Winner's share of Electoral College Votes"
p <-  ggplot(data=elections_historic, aes(x = popular_pct, y = ec_pct,
label = winner_label, color=win_party, shape=win_party))
p + geom_hline(yintercept = 0.5, size = 1.4, color = "gray80") +
geom_vline(xintercept = 0.5, size = 1.4, color = "gray80") +
geom_point() +
geom_text_repel(data=subset(after_1992)) +
scale_x_continuous(labels = scales::percent) +
scale_y_continuous(labels = scales::percent) +
labs(x = x_label, y = y_label, title = p_title, subtitle = p_subtitle,
caption = p_caption)
```


```{r}
p_title <-  "Presidential Elections: Popular & Electoral College Margins"
p_subtitle <-  "1824-2016"
p_caption <-  "Data for 2016 are provisional."
x_label <-  "Winner's share of Popular Vote"
y_label <-  "Winner's share of Electoral College Votes"
p <-  ggplot(data=elections_historic, aes(x = popular_pct, y = ec_pct,
label = winner_label, color=win_party, shape=win_party))
p + geom_hline(yintercept = 0.5, size = 1.4, color = "gray80") +
geom_vline(xintercept = 0.5, size = 1.4, color = "gray80") +
geom_point() +
geom_text_repel(data=subset(after_1992)) +
scale_x_continuous(labels = scales::percent) +
scale_y_continuous(labels = scales::percent) +
labs(x = x_label, y = y_label, title = p_title, subtitle = p_subtitle,
caption = p_caption)
```

### Use geom_point() and reorder() to make a Cleveland dotplot of all presidential elections, ordered by share of the popular vote.



```{r}

# Cleveland dot plot for winners of US presidential elections ordered by their share of popular vote received 

elections_historic %>%
  group_by(winner) %>% 
  ggplot(aes(x = popular_pct, y = reorder(winner, popular_pct))) + geom_point() + 
  labs(title = "Winners of U.S. Presidenial Elections by Percent of Popular Vote", y = "U.S. Presidents", x = "% of Popular Vote") 
  

```

### Try using annotate() to add a rectangle that lightly colors the entire upper left quadrant of figure 5.18.


```{r}
p_title <-  "Presidential Elections: Popular & Electoral College Margins"
p_subtitle <-  "1824-2016"
p_caption <-  "Data for 2016 are provisional."
x_label <-  "Winner's share of Popular Vote"
y_label <-  "Winner's share of Electoral College Votes"
p <-  ggplot(elections_historic, aes(x = popular_pct, y = ec_pct,
label = winner_label))
p + geom_hline(yintercept = 0.5, size = 1.4, color = "gray80") +
geom_vline(xintercept = 0.5, size = 1.4, color = "gray80") +
geom_point() +
geom_text_repel() +
scale_x_continuous(labels = scales::percent) +
scale_y_continuous(labels = scales::percent) +
labs(x = x_label, y = y_label, title = p_title, subtitle = p_subtitle,
caption = p_caption)+ 
  annotate("rect", xmin = 0.3, xmax=0.5, ymin =0.5, ymax=1, fill="red", alpha=0.1)
```

### The main action verbs in the dplyr library are group_by(), filter(), select(), summarize(), and mutate(). Practice with them by revisiting the gapminder data to see if you can reproduce a pair of graphs from chapter 1, shown here again in figure 5.28. You will need to filter some rows, group the data by continent, and calculate the mean life expectancy by continent before beginning the plotting process.

```{r}
library(ggthemes) # used below for the minimal theme 

# first, using mutate to calculate avg. life expectancy 
gapminder %>% 
  filter(year == 2007) %>% 
  select(continent, lifeExp) %>% 
  group_by(continent) %>% 
  mutate(continent_mean = mean(lifeExp)) %>% 
  ggplot(aes(x = continent_mean, y = reorder(continent, continent_mean))) + geom_point() + 
  labs(title = "Mean Life Expectancy in 2007 by Continent", x = "Life Expectancy (Years)", 
       y = "Continent") + theme_minimal() 

# same plot as above but using summarize instead of mutate to calculate means 
gapminder %>% 
  filter(year == 2007) %>% 
  select(continent, lifeExp) %>% group_by(continent) %>% 
  summarize(exp_mean = mean(lifeExp)) %>%
  ggplot(aes(x = exp_mean, y = reorder(continent, exp_mean))) + geom_point() + 
  labs(title = "Mean Life Expectancy in 2007 by Continent", x = "Life Expectancy (Years)", 
       y = "Continent") + theme_minimal() 


```





### Get comfortable with grouping, mutating, and summarizing data in pipelines. This will become a routine task as you work with your data. There are many ways that tables can be aggregated and transformed. Remember, group_by() groups your data from left to right, with the rightmost or innermost group being the level calculations will be done at; mutate() adds a column at the current level of grouping; and summarize() aggregates to the next level up. Try creating some grouped objects from the GSS data, calculating frequencies as you learned in this chapter, and then check to see if the totals are what you expect. For example, start by grouping degree by race, like this:

```{r}
# Healy example: 
gss_sm %>% group_by(race, degree) %>%
    summarize(N = n()) %>%
    mutate(pct = round(N / sum(N)*100, 0)) 
```



```{r}
gss_sm %>% group_by(race, degree) %>% summarize(N = n()) %>%
mutate(pct = round(N/sum(N) * 100, 0)) %>% summarize(total = sum(pct))
```

As expected, this sums to 100 within each race, with a bit of rounding error.

### This code is similar to what you saw earlier but more compact. (We calculate the pct values directly.) Check that the results are as you expect by grouping by race and summing the percentages. Try doing the same exercise grouping by sex or region.


```{r}
gss_sm %>% group_by(region, degree) %>% summarize(N = n()) %>%
mutate(pct = round(N/sum(N) * 100, 0)) 
```


```{r}
gss_sm %>% group_by(region, degree) %>% summarize(N = n()) %>%
mutate(pct = round(N/sum(N) * 100, 0))%>% summarize(total = sum(pct))
```
As expected, this sums to 100 within each region, with a bit of rounding error.

### Try summary calculations with functions other than sum. Can you calculate the mean and median number of children by degree? (Hint: the childs variable in gss_sm has children as a numeric value.)


```{r}
gss_sm %>% group_by(degree) %>% 
  summarize(childsmean=mean(childs, na.rm=TRUE), 
            childsmedian=median(childs, na.rm=TRUE))
```

### dplyr has a large number of helper functions that let you summarize data in many different ways. The vignette on window functions included with the dplyr documentation is a good place to begin learning about these. You should also look at chapter 3 of Wickham & Grolemund (2016) for more information on transforming data with dplyr.

### Experiment with the gapminder data to practice some of the new geoms we have learned. Try examining population or life expectancy over time using a series of boxplots. (Hint: you may need to use the group aesthetic in the aes() call.) Can you facet this boxplot by continent? Is anything different if you create a tibble from gapminder that explicitly groups the data by year and continent first, and then create your plots with that?



```{r}
# boxplot with life expectancy over time (years)
ggplot(gapminder, aes(x=year, y=lifeExp, group=continent)) + 
  geom_boxplot() 

# same as above but first grouping by year and continent first and grouping by year to show life expectancy distributions within continent across years 

gapminder %>% 
  group_by(continent, year) %>% 
  ggplot(aes(x = year, y = lifeExp, group = year)) + geom_boxplot() + facet_wrap(~continent) 

```


### Read the help page for geom_boxplot() and take a look at the notch and varwidth options. Try them out to see how they change the look of the plot.

```{r, message = FALSE}

#?geom_boxplot() # view geom_boxplot() documentation 

# notched boxplot 
gapminder %>% 
  filter(continent == "Europe") %>% 
  ggplot(aes(x  = year, y = lifeExp, group = year)) + geom_boxplot(notch = TRUE)

# adjust varwidth options 
gapminder %>% 
  filter(continent == "Europe") %>% 
  ggplot(aes(x  = year, y = lifeExp, group = year)) + geom_boxplot(varwidth = TRUE)


```



### As an alternative to geom_boxplot(), try geom_violin() for a similar plot but with a mirrored density distribution instead of a box and whiskers.


```{r}
# violin plot 
ggplot(gapminder, aes(x=year, y=lifeExp, group=continent, fill=continent)) + 
  geom_violin() 
```


### geom_pointrange() is one of a family of related geoms that produce different kinds of error bars and ranges, depending on your specific needs. They include geom_linerange(), geom_crossbar(), and geom_errorbar(). Try them out using gapminder or organdata to see how they differ.


```{r}

# geom error bar 
lower = 0
upper = 90

gapminder %>%
  ggplot(aes(x = continent, y = lifeExp)) + geom_col(position = "dodge") +
 geom_errorbar(aes(ymin = lower, ymax = upper), position = "dodge", width = 0.25)


# point range 
gapminder %>% 
   filter(continent == "Africa") %>%  
  ggplot(aes(x = year, y = lifeExp, group = year, 
                     ymin= 20, ymax= 80)) + geom_pointrange() 

# geom_crossbar 
gapminder %>% 
  filter(continent %in% c("Africa", "Europe"), year %in% c(1952, 1962, 1997))  %>% 
  group_by(continent) %>% 
  mutate(year = as.factor(year), pop_mean = mean(pop)) %>%
  ggplot(aes(x = year, y = pop_mean, group = continent,color = continent, ymin = 4500000, ymax = 20000000)) + geom_crossbar() 


```






Load packages used across exercises 

```{r, message = FALSE}
library(tidyverse) 
```




# Tidy Tuesday Challenge 


In the following Tidy Tuesday screen cast, David Robinson explores an open-source data set from the National Science Foundation (NSF) that contains the number of PhDs awarded each year by academic discipline. Within discipline, the data set contains broad field, major, and minor disciplines in order of specificity of the students' area of research, respectively. 

A. The original data visualization that inspired that week of Tidy Tuesday.
B. Information and a link to the dataset.
C. A paragraph on your plan to improve the data visualization.
D. The code and your improved data visualization.
E. A few paragraphs on how the data visualization addresses the issues with Gestalt theory and the visual perception research.
F. A brief discussion of any major issues, snags, or hurdles you ran into and overcame during the process.

#### Read in data from GitHub repo 

```{r, message = FALSE}
library(readr) 

urlfile="https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-02-19/phd_by_field.csv"

phd_raw <- read_csv(url(urlfile)) # store a raw version in case needed later after data cleaning 

# explore data set 
head(phd_raw) 

# explore structure of data after loading into R 
str(phd_raw) 
class(phd_raw)

# store as data frame
phd_df <- as.data.frame(phd_raw) 

```

### Data Cleaning 

```{r}

# rename field to 'minor field' 

phd_clean <- phd_df %>% 
  rename(minor_field = field) 

# store field as a factor below so that it's a group not character string and rename to match 
# David Robinson's naming convention from his Tidy Tuesday screencast 
phd_clean <- phd_clean %>% 
  mutate(field = as.factor(broad_field), 
         year = as.factor(year))  

phds_by_year <- phd_clean %>% 
  filter(!is.na(n_phds)) %>%
  group_by(year, field) %>% 
  summarize(num_degrees = mean(n_phds)) 


```



Exploratory data analysis 



Per the code below, we have gleaned the following facts about the data set: 
    + There are 10 years captured in the data set ranging from 2008 to 2017
    + There are 7 broad fields: 
    + Over the 10 years, life sciences graduated the most PhDs (n = 1,320) and mathematics & computer science the fewest (n = 160)
    + 

```{r}

# how many years in data set overall? 

phd_clean %>%
  select(year) %>% 
  group_by(year) %>% arrange(desc(year)) %>% distinct() 

# how many broad fields?

phd_clean %>%
  group_by(major_field) %>% 
  count(major_field) %>% arrange(desc(n)) 


# how many major fields in general? 

phd_clean %>% 
  group_by(major_field) %>%
  count(major_field) %>% arrange(desc(n)) 

# how many fields per major field on average? 


```


[insert David Robinson's line graph]


```{r}

phd_clean
library(ggtext) 

# line plot with selective attuning for education PhD degrees 
phds_by_year
phds_by_year %>%
  ggplot(aes(x = year, y = num_degrees, group = field, color = field)) + geom_line() 


phds_by_year %>%
  mutate(highlight = ifelse(field=="Education", "Education", "Other Fields")) %>%
  ggplot(aes(x=year, y=num_degrees, group= field, color=highlight, size=highlight)) +
    geom_line() +
    scale_color_manual(values = c("#69b3a2", "grey50")) +
    scale_size_manual(values=c(1.5,0.2)) +
    theme(legend.position="none") +
  labs(
    title = "The number of PhDs in education are decreasing each year", y = "Number of PhDs Awarded", x = "Year")  +
    geom_label( x= 2, y= 3,label="Education PhDs on Decline", size=4, color="#69b3a2") +
      theme(
      legend.position="none",
      plot.title = element_text(size=14))


```





```{r}
library(viridis) 

phds_by_year %>%
  ggplot(aes(x = year, y= num_degrees, group = field)) +
    geom_line(aes(group=field), color="grey", size=0.5, alpha=0.5) +
    geom_line(aes(color=field), color="#69b3a2", size=1.2 )+
    scale_color_viridis(discrete = TRUE) +
    theme(
      legend.position="none",
      plot.title = element_text(size=14),
      panel.grid = element_blank()
    ) +
    ggtitle("PhDs awarded by Field: 2008 to 2016") +
    facet_wrap(~field)
```





