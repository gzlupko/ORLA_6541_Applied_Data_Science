---
title: "ORLA 6541 - Exercise 1"
author: "Nilima Ajaikumar, Hagay Jalon, and Gian Zlupko"
date: '2022-10-03'
output: html_document
---

ORLA 6541 - Exercise 1 

The following code and write-up contains answers to in-text exercises in
Wickham & Grolemund (2017): Chapters 3-6 and Bulut & Dejardins (2019) Chapter 4. 

# Wickham & Grolemund (2017):
### Chapter 3: Data Visualization 


## 3.2.4 Exercises

#### 1.	Run ggplot(data = mpg). What do you see?
A blank grey square

```{r, message = FALSE}
library(tidyverse)

ggplot(data=mpg)
```

#### 2.	How many rows are in mpg? How many columns?
234 rows and 11 columns

```{r}
mpg
```
#### 3. What does the drv variable describe? Read the help for ?mpg to find out.
The drv variable describes the type of drive train for each car in the data set, where f = front-wheel drive, r = rear wheel drive, 4 = 4wd. 

```{r}
?mpg
```

#### 4.	Make a scatterplot of hwy vs cyl.
```{r}
ggplot(data = mpg)+geom_point(mapping=aes(x=cyl, y=hwy))
```

#### 5.	What happens if you make a scatterplot of class vs drv? Why is the plot not useful?

Since both variables are categorical, the points align based on the intersection of both categories, which does not provide any useful information. Scatterplots are more useful for mapping the relationship between two continuous variables. 

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = class, y = drv))
```
## 3.3.1 Exercises
#### 1.	What’s gone wrong with this code? Why are the points not blue? 
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = "blue"))
  
  aes() is used to map an aesthetic to a variable.  In this case, we wanted to associate the aesthetic color and with the actual color “blue”. Since “blue” is not a variable, we cannot map it in aesthetic, and had to set the aesthetic properties of our geom manually (outside of aes() . As such: 


```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")
```


#### 2.	Which variables in mpg are categorical? Which variables are continuous? (Hint: type ?mpg to read the documentation for the dataset). How can you see this information when you run mpg?

```{r}
?mpg
```

Categorical: manufacturer, model, trans, drv, fl, class
Continuous: displ, year, cyl, cty, hwy

You can see this information when running ?mpg under each variable's name

#### 3.	Map a continuous variable to color, size, and shape. How do these aesthetics behave differently for categorical vs. continuous variables?

Assigning color to a continuous variable provides a numerical scale of colors while assigning color to a categorical variable categorizes all levels of the variable by different colors.

Similarly, assigning size to a continuous variable provides a numerical scale of sizes, while assigning size to a categorical variable (although not advised), categorizes all levels of the variable by different sizes.

Continuous variables can not be mapped to shape. While assigning shape to a categorical variable, all levels of the variable by different shapes (with a maximum of 6 discrete values because more than 6 becomes difficult to discriminate)


```{r}
ggplot(data = mpg) + 
    geom_point(mapping = aes(x = displ, y = hwy, color = cty))
```

```{r}
ggplot(data = mpg) + 
    geom_point(mapping = aes(x = displ, y = hwy, size = cty))
```

#### 4.	What happens if you map the same variable to multiple aesthetics? 

You get a scatterpllot with an overlap of two aesthetics, both convey the same information. 

```{r}
ggplot(data = mpg) + 
    geom_point(mapping = aes(x = displ, y = hwy, color = cty, alpha=cty))
```

#### 5.	What does the stroke aesthetic do? What shapes does it work with? (Hint: use ?geom_point)

It is used to modify the width of the border of shapes with borders. 

```{r}
?geom_point
```


#### 6.	What happens if you map an aesthetic to something other than a variable name, like aes(colour = displ < 5)? Note, you’ll also need to specify x and y.

It categorizes the variable assigned to the x-axis (in this case, displ) to < or > 5 by two different colors. 

```{r}
ggplot(data = mpg) + 
    geom_point(mapping = aes(x = displ, y = hwy, color = displ<5))
```

## 3.5.1 Exercises

#### 1.	What happens if you facet on a continuous variable?

We get a new column for each value of the variable.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap(~ cty, nrow = 2)
```


#### 2.	What do the empty cells in plot with facet_grid(drv ~ cyl) mean? How do they relate to this plot?


```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_grid(drv ~ cyl)
```
The empty cells in `facet_grid` suggest that the variables did not intersect within these values. This relates to the first plot because we can notice that in the first plot, there is much empty space and if we were to facet it, we are likely to have empty cells as well.


#### 3.	What plots does the following code make? What does . do?

`.` allows us to facet the plot by all levels of the variable provided without needing to specify the levels. 

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(drv ~ .)

```


```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(. ~ cyl)
```

#### 4. Take the first faceted plot in this section: What are the advantages to using faceting instead of the colour aesthetic? What are the disadvantages? How might the balance change if you had a larger dataset?


```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap(~ class, nrow = 2)
```
Advantages: it is easier to identify patterns within each value of a variable; we can have a larger number of facets while still being able to identify which facet represents which value, while with a large number of colors, it may be  difficult to discriminate between values. 
Disadvantages: It may be more challenging to compare patterns between values of the variable and to identify overall patterns.

#### 5. Read ?facet_wrap. What does nrow do? What does ncol do? What other options control the layout of the individual panels? Why doesn’t facet_grid() have nrow and ncol arguments?

```{r}
?facet_wrap
```
`nrow` determines the number of rows in the facet. Other options that control the layout of the individual panels are: `ncol`, scale, and dir. `ncol` determines the number of columns in the facet. `facet_grid`() does not have number of `nrow` and `ncol` arguments because they are determined by the number of unique levels the variables have.

#### 6. When using facet_grid() you should usually put the variable with more unique levels in the columns. Why?

Because if you put the variable with the more unique levels in the rows, it would create a taller then wider plot, which may be hard to follow and interpret on most computers.

## 3.6.1 Exercises

#### 1. What geom would you use to draw a line chart? A boxplot? A histogram? An area chart?

line chart - `geom_line()`
boxplot - `geom_boxplot()`
histogram - `geom_histogram()`


#### 2. Run this code in your head and predict what the output will look like. Then, run the code in R and check your predictions.

This will create a scatter plot with displ as the x variable and hwy as the y variable. drv will be represented by both lines and errors colored by the levels of the variable, and their standard error would not appear.

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + 
  geom_point() + 
  geom_smooth(se = FALSE)
```


#### 3. What does show.legend = FALSE do? What happens if you remove it? Why do you think I used it earlier in the chapter?

show.legend = FALSE hides the legend box in the of the plot. It plausible that it was removed to ensure the plot's size is consistent with previous plots.


#### 4. What does the se argument to geom_smooth() do?

It visulizes the confidence intervals of the line as shaded areas; TRUE to show, FALSE to hide.

#### 5. Will these two graphs look different? Why/why not?


```{r, message = FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()
```


```{r, message = FALSE}
ggplot() + 
  geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))
```

No, they will be identical since Because both geom_point() and geom_smooth() will uses the same data and mapping noted in the ggplot(), which is the same for both plots. 

#### 6. Recreate the R code necessary to generate the following graphs.


```{r, message = FALSE}
ggplot(data=mpg, mapping=aes(x = displ, y = hwy,)) +
  geom_point(size=5) +
  geom_smooth(se = FALSE, size=2)
```


```{r, message = FALSE}
 ggplot(data = mpg, mapping = aes(x = displ, y = hwy))+
     geom_smooth(mapping = aes(group = drv), se = FALSE, size=2) +
  geom_point(size=5)
```


```{r, message = FALSE}
 ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color=drv))+
     geom_smooth(se = FALSE, size=2) +
  geom_point(size=5)
```


```{r, message = FALSE}
ggplot(data = mpg, mapping = aes (x = displ, y = hwy))+
     geom_smooth(se = FALSE, size=2) +
  geom_point(mapping=aes(color=drv), size=5)
```


```{r, message = FALSE}
 ggplot(data = mpg, mapping = aes(x = displ, y = hwy))+
     geom_smooth(mapping=aes(linetype=drv), se = FALSE, size=2) +
  geom_point(mapping = aes(color=drv), size=5)
```

```{r, message = FALSE}
 ggplot(data = mpg, mapping = aes(x = displ, y = hwy))+
geom_point(size = 5, color = "white") +
  geom_point(aes(color = drv))
```

## 3.7.1 Exercises

#### 1. What is the default geom associated with stat_summary()? How could you rewrite the previous plot to use that geom function instead of the stat function?

```{r}
?stat_summary
```


the default geom associated with stat_summary is geom_pointrange().  
```{r}
ggplot(data = diamonds) + 
  stat_summary(
    mapping = aes(x = cut, y = depth),
    fun.min = min,
    fun.max = max,
    fun = median
  )
```


#### 2. What does geom_col() do? How is it different to geom_bar()?

```{r}
?geom_col
```

```{r}
?geom_bar
```

There are two types of bar charts: geom_bar() and geom_col(). geom_bar() makes the height of the bar proportional to the number of cases in each group (or if the weight aesthetic is supplied, the sum of the weights). If you want the heights of the bars to represent values in the data, use geom_col() instead. geom_bar() uses stat_count() by default: it counts the number of cases at each x position. geom_col() uses stat_identity(): it leaves the data as is.

#### 3. Most geoms and stats come in pairs that are almost always used in concert. Read through the documentation and make a list of all the pairs. What do they have in common?

Pairs of geoms and stats share names in common and typically have the same default stat.

#### 4. What variables does stat_smooth() compute? What parameters control its behaviour?

```{r}
?stat_smooth
```
Two parameters that control `stat_smooth()'`s behavior are `method` and `formula.` Method specifies the kind of smoothing function to apply, like a linear model (lm) or a generalized linear model (glm), and formula allows the user to provide the variables of interest for the given modeling strategy. In addition, users can also adjust the `fullrange` parameter, which tells R to either fit the smoothing for just the data or the full plot. 

stat_smooth() generates the following variables: 

y or x
predicted value of the given variable(s) 

ymin or xmin
lower pointwise confidence interval around the mean

ymax or xmax
upper pointwise confidence interval around the mean

se
standard error



#### 5.In our proportion bar chart, we need to set group = 1. Why? In other words what is the problem with these two graphs?

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = after_stat(prop)))
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = color, y = after_stat(prop)))
```


The problems is that all of the bars are the same height, which is inaccurate. Setting group=1 ensures that the proportions for each stack are calculated using each subset. 
  
  
## 3.8.1 Exercises

#### 1. What is the problem with this plot? How could you improve it?


```{r}
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + 
  geom_point()
```
It is possible that many points in the plot overlap and, therefore, hide each other. We can improve the plot by using the geom_jitter() function to add a small amount of random noise to each point, which will reveal any overlapping points. As such:

  
```{r}
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + 
  geom_jitter()
```


#### 2. What parameters to geom_jitter() control the amount of jittering?

Width, controlling the horizontal random noise, and height, controlling the vertical random noise.
```{r}
?geom_jitter
```


#### 3. Compare and contrast geom_jitter() with geom_count().

```{r}
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + 
  geom_count()
```
While `geom_jitter` adds random noise to each point to reduce over plotting of points, `geom_count` changes the size of each point per the number of observation for its specific value. Although geom_count can help to reduce over plotting; however, it may create over plotting by itself due to the size of the points.


#### 4. What’s the default position adjustment for geom_boxplot()? Create a visualisation of the mpg dataset that demonstrates it.


```{r}
?geom_boxplot
```


The default position adjustment for geom_boxplot() is dodge2.

```{r}
ggplot(data = mpg, aes(x = drv, y = hwy)) +
  geom_boxplot()
```


## 3.9.1 Exercises

#### 1. Turn a stacked bar chart into a pie chart using coord_polar().

```{r}
ggplot(mpg, aes(x = class, fill = drv)) + geom_bar()
```


```{r}
ggplot(mpg, aes(x = class, fill = drv)) + geom_bar() + coord_polar()
```

#### 2. What does labs() do? Read the documentation.

```{r}
?labs()
```

`labs()` allows users to set plot labels. Within the `labs()` function, users can provide details for host of plot labels, like title, subtitle, caption, and more. 

#### 3. What’s the difference between coord_quickmap() and coord_map()?


```{r}
?coord_quickmap
```

`coord_map()` from ggplot2 allows users to map their data onto a 2D projection of the earth. Due to the curvature of the earth, the documentation notes that map projections do not preserve straigth lines. As such, `coord_quickmap()` can be used alternatively, which performs calculations to provide an approximation of the requested area of the globe but with straight lines. 


#### 4. What does the plot below tell you about the relationship between city and highway mpg? Why is coord_fixed() important? What does geom_abline() do?

The plot below suggests a strong positive relationship between city miles per gallon to highway miles per gallon; as one rises, so does that other. 

coord_fixed() is important because it ensures a fixed ratio between the physical representation of data points on the X and Y axes. This makes it easier to identify patterns in the plot.

geom_abline() adds a reference line to a plot, either horizontal, vertical, or diagonal, which is useful for annotating plots. In this case, it added a horizontal line to the plot, which made it easier to identify the relationship between city and highway mpg.


```{r}
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +
  geom_point() + 
  geom_abline() +
  coord_fixed()
```


```{r}
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +
  geom_point() + 
  geom_abline()
```


```{r}
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +
  geom_point() + 
  coord_fixed()
```


# Wickham & Grolemund Chapter 4 
### Workflow: basics


## 4.4 Exercises

#### 1. Why does this code not work?

my_variable <- 10
my_varıable
#> Error in eval(expr, envir, enclos): object 'my_varıable' not found

This code does not work because the "I" in the second row of the code is capital, which does not match the "i" above. 

#### 2. Tweak each of the following R commands so that they run correctly:

`library(tidyverse)`

`ggplot(dota = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))`

`fliter(mpg, cyl = 8)
filter(diamond, carat > 3)
`

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```

```{r}
filter(mpg, cyl == 8)
filter(diamonds, carat > 3)
```

#### 3. Press Alt + Shift + K. What happens? How can you get to the same place using the menus?

A menu with all shortcuts appear. I can access this menu through Tools, keyboard shortcuts helps.


```{r libaries, message = FALSE}
library(tidyverse) 
```



# Bulut & Dejardins (2019) Chapter 4 
### Wrangling big data with data.table

This chapter demonstrates the application of the `data.table` in R as an alternative to tidyverse and base R methods of data wrangling. The authors suggest that  `data.table` is particularly useful for working with large volumes of data (e.g. 10 - 100 GB)

```{r, message = FALSE}
library(data.table) 
```

##  4.2.1 Exercises
#### 1. Read in the pisa data set. Either the full data set (recommended to have > 8 Gb of RAM) or one of the smaller data sets.

Due to slow loading speeds when importing the full pisa data set, even with `fread()` from data.table, we decided to use the smaller 'random6' data set that the authors also made a available. According to the authors, the random data set contains data collected from a random sample of a single country with records from all 6 of its regions. 


```{r}
# read in the random data set 
random6 <- fread("random6.csv", na.strings = "") 

# check object size - 0.2 gigabytes 
print(object.size(random6), unit = "GB") 

# read in pisa data set 
#pisa <- fread("pisa2015.csv") 

```

## 4.3.1 Exercises
#### 1. Subset all the Female students (ST004D01T) in Germany. 
#### 2. How many female students are there in Germany?
#### 3. The .N function returns the length of a vector/number of rows. Use chaining with the .N function to answer Exercise 2.

Using data.table syntax to subset the data set, we found that there are 3,197 female students from Germany in the data set. In addition, an alternative method using the ` .N ` function to return the number of rows is shown below as well. 

```{r}
# explore data; first 5 and last 5 rows returned when printing a data.table object 
#random6 # don't run for now due to loading speed 

# subset all female students from the field ST004D01T 

#random6[CNT == "Germany" & ST004D01T == "Female"]

# return row count with .N function and chaining 
#random6[CNT == "Germany" & ST004D01T == "Female", .N] # don't print code as the output is very large in the markdown report 

```



## 4.4.1 Exercises
#### 1. The computer and software variables that were created above ask a student whether they had a computer in their home that they can use for school work (computer) and whether they had educational software in their home (software). Find the proportion of students in the Germany and Uruguay that have a computer in their home or have educational software.

```{r}

# first create custom function to convert bin to numeric  

bin.to.num <- function(x){
  if (is.na(x)) NA
  else if (x == "Yes") 1L
  else if (x == "No") 0L
}


# using the custom function, create new variables, computer and software, that we can use to calculate the proportion of students with access to these resources  


random6[, `:=` 
     (female = ifelse(ST004D01T == "Female", 1, 0),
       sex = ST004D01T,
       
       # At my house we have ...
       desk = sapply(ST011Q01TA, bin.to.num),
       own.room = sapply(ST011Q02TA, bin.to.num),
       quiet.study = sapply(ST011Q03TA, bin.to.num),
       computer = sapply(ST011Q04TA, bin.to.num),
       software = sapply(ST011Q05TA, bin.to.num),
       internet = sapply(ST011Q06TA, bin.to.num),
       lit = sapply(ST011Q07TA, bin.to.num),
       poetry = sapply(ST011Q08TA, bin.to.num),
       art = sapply(ST011Q09TA, bin.to.num),
       book.sch = sapply(ST011Q10TA, bin.to.num),
       tech.book = sapply(ST011Q11TA, bin.to.num),
       dict = sapply(ST011Q12TA, bin.to.num),
       art.book = sapply(ST011Q16NA, bin.to.num))]



```

In Germany, 95% of students in Germany have a computer in their home and 45% of students have educational software. 
```{r}
random6[CNTRYID == "Germany", table(computer)] # 247 No's and 5438 Yes' 
# computer prop 
5438 /(5438 + 247)*100 #  95% of students in data set in Germany have a computer in

random6[CNTRYID == "Germany", table(software)] # 3038 No's and 2481 Yes' 
# educational software prop 
2481/(2481 + 3038) # 45% have access to educational software 

```

In Uruguay, 88% of students have a computer in the home and 43% of students have educational software. 
```{r}
random6[CNTRYID == "Uruguay", table(computer)] # 635 No's and 5099 Yes' 
# computer in home prop 
5099/(5099 + 635) # 88% have access to educational software 


random6[CNTRYID == "Uruguay", table(software)] # 3013 No's and 2313 Yes' 
# educational software prop 
2313/(2313 + 3013) # 43% have access to educational software 
```



#### 2. For just female students, find the proportion of students who have their own room (own.room) or a quiet place to study (quiet.study).

Among female students in the random6 data set, 72% stated that they have their own room and 85% stated that they have a quiet place to study. 
```{r}

random6[female == 1, table(own.room)] # 4805 No's and 12644 Yes' 
# prop own.room

12644 / (12644 + 4805) #72% 

random6[female == 1, table(quiet.study)] #2606 No's and 14801 Yes' 
# prop quiet.study 

14801 / (14801 + 2606) # 85% 

```


## 4.5.1 Exercises
#### 1. Calculate the proportion of students who have art in their home (art) and the average age (AGE) of the students by gender.

51% of students have art in their home. The average age of male and female students are 15.8 years. 

```{r}
# proportion of students who have art in their homes: 
random6[, .(art = mean(art, na.rm = TRUE), AGE = mean(AGE, na.rm = TRUE)), by = .(sex)] 

```


#### 2. Within a by argument you can discretize a variable to create a grouping variable. Perform a median split for age within the by argument and assess whether there are age difference associated with having your own room (own.room) or a desk (desk).

```{r}

# create custom function to split a column of data by above or below median 
median_cut = function(x) { 
  ifelse(x > median(x), "above_median", "below_median")
}


random6[,
     .(own.room = mean(own.room, na.rm = TRUE), 
       desk_mean = mean(desk, na.rm = TRUE)), 
     by = .(median_cut(AGE)) ] 


```

The authors show that the code below, using the `melt()` function, can be used to reshape the data sets from wide to long formats. 
```{r, include = FALSE}
#
random6$id <- 1:nrow(random6) 
athome <- subset(random6, select = c(id, desk:art.book))


# reshape data to long format using melt function 
athome.l <- melt(athome, 
                 id.vars = "id",
                 measure.vars = c("desk", "own.room", "quiet.study", "lit",
                                  "poetry", "art", "book.sch", "tech.book",
                                  "dict", "art.book"))
# view at home long format 
athome.l


```


## 4.8 Lab 

#### 1. This afternoon when we discuss supervised learning, we’ll ask you to develop some models to predict the response to the question Do you expect your child will go into a ?" (PA032Q03TA). Recode this variable so that a “Yes” is 1 and a “No” is a -1 and save the variable as sci_car.

```{r}

# recode and store as 'sci_car'; use table to confirm re-coding
random6[, 
        "sci_car" := sapply(PA032Q03TA, 
                            function(x) { 
                              if (is.na(x)) NA
                              else if (x == "No") -1L 
                              else if (x == "Yes") 1L 
                              
                              }) ][,
                                    table(sci_car)]

```



#### 2. Calculate descriptives for this variable by sex and country. Specifically, the proportion of test takers whose parents said “Yes” or 1.

Because we are using the more limited random6 data set, we specify to return Germany and Mexico specifically, since the other countries are not in the data set. 


```{r}

random6[CNTRYID %in% c("Germany", "Mexico"), 
        .(mean(sci_car, na.rm = TRUE)), 
        by = .(sex, CNTRYID)]

```

#### 3. Means and standard deviations (sd) for the variables that you think will be most predictive of sci_car.

```{r}

# means and sd of variables hypothesized to predict sci_car
random6[, 
        .(environ_avg =  mean(ENVAWARE, na.rm = TRUE), 
          environ_sd = sd(ENVAWARE, na.rm = TRUE), 
          joy_avg = mean(JOYSCIE, na.rm = TRUE), 
          joy_sd = sd(JOYSCIE, na.rm = TRUE), 
          self_eff_avg = mean(SCIEEFF, na.rm = TRUE), 
          self_eff_sd = sd(SCIEEFF, na.rm = TRUE)
          )]


```

#### 4. Calculate these same descriptives by groups (by sci_car and by sex).

```{r}
# means and sd of focal variables, grouped by sci_car and sex 
random6[, 
        .(environ_avg =  mean(ENVAWARE, na.rm = TRUE), 
          environ_sd = sd(ENVAWARE, na.rm = TRUE), 
          joy_avg = mean(JOYSCIE, na.rm = TRUE), 
          joy_sd = sd(JOYSCIE, na.rm = TRUE), 
          self_eff_avg = mean(SCIEEFF, na.rm = TRUE), 
          self_eff_sd = sd(SCIEEFF, na.rm = TRUE)
          ), by = .(sci_car, sex)]

```

#### 5. Calculate correlations between these variables and sci_car


```{r}

# first store smaller data set containing observations for all focal variables and sci_car 
sci_car_variables <- random6[, 
        .(sci_car, ENVAWARE, JOYSCIE, SCIEEFF)]

sci_car_variables[, 
                   .(env_joy_cor = cor(x = ENVAWARE, y = JOYSCIE, use = "complete.obs"),
                   joy_self_eff_cor = cor(x = JOYSCIE, y = SCIEEFF, use = "complete.obs"), 
                   env_sci_car_cor = cor(x = ENVAWARE, y = sci_car, use = "complete.obs"), 
                   sci_car_joy_cor = cor(x = JOYSCIE, y = sci_car, use = "complete.obs"))]



```

#### 6. Create new variables: Discretize the math and reading variables using the OECD means (490 for math and 493) and code them as 1 (at or above the mean) and -1 (below the mean), but do in the data.table way without using the $ operator.

```{r,warning=FALSE}

# recode and store as 'sci_car'; use table to confirm re-coding
random6[, 
        "math_split" := sapply(PV1MATH, 
                            function(x) { 
                              if (is.na(x)) NA
                              else if (x <= 490) -1L 
                              else if (x > 490) 1L 
                              
                              })][,
                                    table(math_split)]

random6[, 
               "reading_split" := sapply(PV1READ, 
                            function(x) { 
                              if (is.na(x)) NA
                              else if (x <= 493) -1L 
                              else if (x > 493) 1L}) ][, 
                                                     table(reading_split)]


# calculate correlations with these new variables and those above 
# store as table for subsequent formatting 
math_reading_cor <- random6[, 
                   .(env_joy_cor = cor(x = ENVAWARE, y = JOYSCIE, use = "complete.obs"),
                   joy_self_eff_cor = cor(x = JOYSCIE, y = SCIEEFF, use = "complete.obs"), 
                   env_sci_car_cor = cor(x = ENVAWARE, y = sci_car, use = "complete.obs"), 
                   sci_car_joy_cor = cor(x = JOYSCIE, y = sci_car, use = "complete.obs"), 
                   math_joy_cor = cor(x = math_split, y = sci_car, use = "complete.obs"), 
                   reading_joy_cor = cor(x = reading_split, y = sci_car, use = "complete.obs"), 
                   math_env_cor = cor(x = ENVAWARE, y = math_split, use = "complete.obs"), 
                   reading_env_cor = cor(x = JOYSCIE, y = reading_split, use = "complete.obs"), 
                   math_self_eff_cor = cor(x = SCIEEFF, y = math_split, use = "complete.obs"), 
                  reading_self_eff_cor = cor(x = SCIEEFF, y = reading_split, use = "complete.obs"))] 

# pivot long using melt(); easier to view correlations this way 
melt(math_reading_cor) 

```

#### 7. Chain together a set of operations: For example, create an intermediate variable that is the average of JOYSCIE and INTBRSCI, and then calculate the mean by country by sci_car through chaining.

```{r}

random6[, .(Mean = rowMeans(.SD)), by = CNTRYID, .SDcols = c("JOYSCIE", "INTBRSCI")][,,by = sci_car]

```



#### 8. Transform variables, specifically recode MISCED and FISCED from characters to numeric variables.

```{r}

# create column subset to convert to numeric
cols_to_convert <- c("MISCED", "FISCED") 

# convert to numeric with subset index and using lapply() 
random6[ , 
           (cols_to_convert) := lapply(.SD, as.numeric),
           .SDcols = c("MISCED", "FISCED")]


```

#### 9. Examine other variables in the pisa data set that you think might be predictive of PA032Q03TA.

```{r}
library(psych) 

random6[, lapply(.SD, mean), .SDcols = c("DISCLISCI", "TEACHSUP", "IBTEACH", "TDTEACH")]


# run descriptive statistics for three additional variables hypothesized to relate to PA032Q03TA 
descriptive_stats <- random6[ ,lapply(.SD, psych::describe), 
         .SDcols = c("DISCLISCI", "TEACHSUP","TDTEACH")] 

# reshape table into long format so that it is easier to read the output
melt(descriptive_stats) 




```





